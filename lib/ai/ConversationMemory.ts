// lib/ai/ConversationMemory.ts
// Week 1, Day 2 - Conversation Memory Module
// Purpose: Load, persist, and search conversation history for context

import { supabase } from '@/lib/supabase/client';
import type {
  ConversationTurn,
  ConversationMemoryResult,
} from '@/types/ai';

/**
 * ConversationMemory - Persistent conversation history manager
 *
 * Responsibilities:
 * - Load recent conversation turns from Supabase
 * - Persist new turns with optional snapshots
 * - Search for relevant past context (keyword-based v1)
 *
 * Performance target: <100ms for load()
 * Never throws - always returns safe defaults on errors
 */
export class ConversationMemory {
  private userId: string;
  private projectId: string;
  private supabase = supabase;

  constructor(userId: string, projectId: string) {
    this.userId = userId;
    this.projectId = projectId;
  }

  /**
   * Load recent conversation history for the current user + project.
   *
   * @param maxTurns - Maximum number of recent turns to load (default: 20)
   * @returns ConversationMemoryResult with recent turns, summary, and metadata
   *
   * Performance: Uses indexed query (user_id, project_id, created_at DESC)
   * Error handling: Returns empty result on database errors (never throws)
   */
  async load(maxTurns: number = 20): Promise<ConversationMemoryResult> {
    try {
      const { data, error } = await this.supabase
        .from('conversation_history')
        .select('*')
        .eq('user_id', this.userId)
        .eq('project_id', this.projectId)
        .order('created_at', { ascending: false })
        .limit(maxTurns);

      if (error) {
        console.error('[ConversationMemory.load] Database error:', error);
        return this.getEmptyResult();
      }

      if (!data || data.length === 0) {
        return this.getEmptyResult();
      }

      // Map database rows to ConversationTurn type
      const turns: ConversationTurn[] = data.map((row) => ({
        id: row.id,
        userId: row.user_id,
        projectId: row.project_id,
        role: row.role,
        message: row.message,
        timestamp: new Date(row.created_at).getTime(),
        source: row.source,
        wizardStateSnapshot: row.wizard_state_snapshot ?? undefined,
        triggersHandled: row.triggers_handled ?? undefined,
        patchesApplied: row.patches_applied ?? undefined,
      }));

      return {
        recent: turns,
        summary: null, // TODO: Week 1 Day 3 - implement summarization for long histories
        turnCount: turns.length,
        hasLongHistory: turns.length >= maxTurns,
      };
    } catch (error) {
      console.error('[ConversationMemory.load] Unexpected error:', error);
      return this.getEmptyResult();
    }
  }

  /**
   * Persist a new conversation turn to the database.
   *
   * @param turn - The turn to persist (without id, will be generated by DB)
   * @returns The persisted turn with generated id, or null on error
   *
   * Error handling: Returns null on insert failures (graceful degradation)
   */
  async addTurn(
    turn: Omit<ConversationTurn, 'id'>
  ): Promise<ConversationTurn | null> {
    try {
      // Map ConversationTurn to database schema
      const row = {
        user_id: turn.userId,
        project_id: turn.projectId,
        role: turn.role,
        message: turn.message,
        source: turn.source,
        wizard_state_snapshot: turn.wizardStateSnapshot ?? null,
        triggers_handled: turn.triggersHandled ?? null,
        patches_applied: turn.patchesApplied ?? null,
        created_at: new Date(turn.timestamp).toISOString(),
      };

      const { data, error } = await this.supabase
        .from('conversation_history')
        .insert(row)
        .select();

      if (error) {
        console.error('[ConversationMemory.addTurn] Insert error:', error);
        return null;
      }

      if (!data || data.length === 0) {
        console.warn('[ConversationMemory.addTurn] No data returned after insert');
        return null;
      }

      const inserted = data[0];

      return {
        id: inserted.id,
        userId: inserted.user_id,
        projectId: inserted.project_id,
        role: inserted.role,
        message: inserted.message,
        timestamp: new Date(inserted.created_at).getTime(),
        source: inserted.source,
        wizardStateSnapshot: inserted.wizard_state_snapshot ?? undefined,
        triggersHandled: inserted.triggers_handled ?? undefined,
        patchesApplied: inserted.patches_applied ?? undefined,
      };
    } catch (error) {
      console.error('[ConversationMemory.addTurn] Unexpected error:', error);
      return null;
    }
  }

  /**
   * Search for relevant past conversation turns using keyword matching.
   *
   * @param query - The search keyword (case-insensitive)
   * @param limit - Maximum results to return (default: 5)
   * @returns Array of matching turns, ordered by recency
   *
   * Version 1: Simple ILIKE keyword matching (no ML/embeddings)
   * Future: Week 2+ will add semantic search with vector embeddings
   */
  async getRelevantContext(
    query: string,
    limit: number = 5
  ): Promise<ConversationTurn[]> {
    try {
      const { data, error } = await this.supabase
        .from('conversation_history')
        .select('*')
        .eq('user_id', this.userId)
        .eq('project_id', this.projectId)
        .ilike('message', `%${query}%`)
        .order('created_at', { ascending: false })
        .limit(limit);

      if (error) {
        console.error('[ConversationMemory.getRelevantContext] Query error:', error);
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      return data.map((row) => ({
        id: row.id,
        userId: row.user_id,
        projectId: row.project_id,
        role: row.role,
        message: row.message,
        timestamp: new Date(row.created_at).getTime(),
        source: row.source,
        wizardStateSnapshot: row.wizard_state_snapshot ?? undefined,
        triggersHandled: row.triggers_handled ?? undefined,
        patchesApplied: row.patches_applied ?? undefined,
      }));
    } catch (error) {
      console.error('[ConversationMemory.getRelevantContext] Unexpected error:', error);
      return [];
    }
  }

  /**
   * Returns safe empty result for error cases.
   * @private
   */
  private getEmptyResult(): ConversationMemoryResult {
    return {
      recent: [],
      summary: null,
      turnCount: 0,
      hasLongHistory: false,
    };
  }
}
