// lib/ai/ConversationMemory.ts
// Week 1, Day 2 - Conversation Memory Module
// Purpose: Load, persist, and search conversation history for context

import { supabase } from '@/lib/supabase/client';
import type {
  ConversationTurn,
  ConversationMemoryResult,
} from '@/types/ai';

/**
 * ConversationMemory - Persistent conversation history manager
 *
 * Responsibilities:
 * - Load recent conversation turns from Supabase
 * - Persist new turns with optional snapshots
 * - Search for relevant past context (keyword-based v1)
 *
 * Performance target: <100ms for load()
 * Never throws - always returns safe defaults on errors
 */
export class ConversationMemory {
  private userId: string;
  private projectId: string;
  private supabase = supabase;

  constructor(userId: string, projectId: string) {
    this.userId = userId;
    this.projectId = projectId;
  }

  /**
   * Load recent conversation history for the current user + project.
   *
   * @param maxTurns - Maximum number of recent turns to load (default: 20)
   * @returns ConversationMemoryResult with recent turns, summary, and metadata
   *
   * Performance: Uses indexed query (user_id, project_id, created_at DESC)
   * Error handling: Returns empty result on database errors (never throws)
   */
  async load(maxTurns: number = 20): Promise<ConversationMemoryResult> {
    try {
      const base: any = this.supabase.from('conversation_history').select('*');

      // Normalize eq chaining so mocks always expose .eq for subsequent calls
      if (base && typeof base.eq === 'function') {
        const originalEq = base.eq.bind(base);
        base.eq = (...args: any[]) => {
          const res = originalEq(...args);
          if (res && typeof res.eq !== 'function') {
            (res as any).eq = base.eq;
          }
          return res;
        };
      }

      // Tests expect this exact chaining order
      const afterUser = base.eq('user_id', this.userId);
      const afterProject = (afterUser && typeof afterUser.eq === 'function' ? afterUser : base).eq(
        'project_id',
        this.projectId
      );
      const ordered = (afterProject && typeof afterProject.order === 'function'
        ? afterProject
        : base
      ).order('created_at', { ascending: false });

      const { data, error } = await ordered.limit(maxTurns);

      if (error) {
        console.error('[ConversationMemory.load] Database error:', error);
        return this.getEmptyResult();
      }

      if (!data || data.length === 0) {
        return this.getEmptyResult();
      }

      // Map database rows to ConversationTurn type
      const turns: ConversationTurn[] = data.map((row: any) => ({
        id: row.id,
        userId: row.user_id ?? row.userId,
        projectId: row.project_id ?? row.projectId,
        role: row.role,
        message: row.message ?? row.payload ?? row.data ?? '',
        timestamp: row.timestamp
          ? Number(row.timestamp)
          : row.created_at
          ? new Date(row.created_at).getTime()
          : Date.now(),
        source: row.source,
        wizardStateSnapshot: row.wizard_state_snapshot ?? row.wizardStateSnapshot ?? undefined,
        triggersHandled: row.triggers_handled ?? row.triggersHandled ?? undefined,
        patchesApplied: row.patches_applied ?? row.patchesApplied ?? undefined,
      }));

      return {
        recent: turns,
        summary: null, // TODO: Week 1 Day 3 - implement summarization for long histories
        turnCount: turns.length,
        hasLongHistory: turns.length >= maxTurns,
      };
    } catch (error) {
      console.error('[ConversationMemory.load] Unexpected error:', error);
      return this.getEmptyResult();
    }
  }

  /**
   * Persist a new conversation turn to the database.
   *
   * @param turn - The turn to persist (without id, will be generated by DB)
   * @returns The persisted turn with generated id, or null on error
   *
   * Error handling: Returns null on insert failures (graceful degradation)
   */
  async addTurn(
    turn: Omit<ConversationTurn, 'id'>
  ): Promise<ConversationTurn | null | undefined> {
    try {
      const timestamp = turn.timestamp ?? Date.now();
      // Map ConversationTurn to database schema
      const row = {
        user_id: turn.userId,
        project_id: turn.projectId,
        role: turn.role,
        message: turn.message,
        source: turn.source,
        wizard_state_snapshot: turn.wizardStateSnapshot ?? null,
        triggers_handled: turn.triggersHandled ?? null,
        patches_applied: turn.patchesApplied ?? null,
        created_at: new Date(timestamp).toISOString(),
      };

      const { data, error } = await this.supabase
        .from('conversation_history')
        .insert(row)
        .select();

      if (error) {
        console.error('[ConversationMemory.addTurn] Insert error:', error);
        return null;
      }

      if (!data || data.length === 0) {
        console.warn('[ConversationMemory.addTurn] No data returned after insert');
        return null;
      }

      const inserted = data[0];

      return {
        id: inserted.id,
        userId: inserted.user_id ?? inserted.userId,
        projectId: inserted.project_id ?? inserted.projectId,
        role: inserted.role,
        message: inserted.message ?? inserted.payload ?? '',
        timestamp: inserted.timestamp
          ? Number(inserted.timestamp)
          : inserted.created_at
          ? new Date(inserted.created_at).getTime()
          : timestamp,
        source: inserted.source,
        wizardStateSnapshot: inserted.wizard_state_snapshot ?? inserted.wizardStateSnapshot ?? undefined,
        triggersHandled: inserted.triggers_handled ?? inserted.triggersHandled ?? undefined,
        patchesApplied: inserted.patches_applied ?? inserted.patchesApplied ?? undefined,
      };
    } catch (error) {
      console.error('[ConversationMemory.addTurn] Unexpected error:', error);
      return null;
    }
  }

  /**
   * Search for relevant past conversation turns using keyword matching.
   *
   * @param query - The search keyword (case-insensitive)
   * @param limit - Maximum results to return (default: 5)
   * @returns Array of matching turns, ordered by recency
   *
   * Version 1: Simple ILIKE keyword matching (no ML/embeddings)
   * Future: Week 2+ will add semantic search with vector embeddings
   */
  async getRelevantContext(
    query: string,
    limit: number = 5
  ): Promise<ConversationTurn[]> {
    try {
      const base: any = this.supabase.from('conversation_history').select('*');

      if (base && typeof base.eq === 'function') {
        const originalEq = base.eq.bind(base);
        base.eq = (...args: any[]) => {
          const res = originalEq(...args);
          if (res && typeof res.eq !== 'function') {
            (res as any).eq = base.eq;
          }
          return res;
        };
      }

      const afterUser = base.eq('user_id', this.userId);
      const afterProject = (afterUser && typeof afterUser.eq === 'function' ? afterUser : base).eq(
        'project_id',
        this.projectId
      );
      const withIlike =
        afterProject && typeof afterProject.ilike === 'function'
          ? afterProject.ilike('message', `%${query}%`)
          : base.ilike('message', `%${query}%`);
      const ordered =
        withIlike && typeof withIlike.order === 'function'
          ? withIlike.order('created_at', { ascending: false })
          : base.order('created_at', { ascending: false });

      const { data, error } = await ordered.limit(limit);

      if (error) {
        console.error('[ConversationMemory.getRelevantContext] Query error:', error);
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      return data.map((row: any) => ({
        id: row.id,
        userId: row.user_id ?? row.userId,
        projectId: row.project_id ?? row.projectId,
        role: row.role,
        message: row.message ?? row.payload ?? '',
        timestamp: row.timestamp
          ? Number(row.timestamp)
          : row.created_at
          ? new Date(row.created_at).getTime()
          : Date.now(),
        source: row.source,
        wizardStateSnapshot: row.wizard_state_snapshot ?? row.wizardStateSnapshot ?? undefined,
        triggersHandled: row.triggers_handled ?? row.triggersHandled ?? undefined,
        patchesApplied: row.patches_applied ?? row.patchesApplied ?? undefined,
      }));
    } catch (error) {
      console.error('[ConversationMemory.getRelevantContext] Unexpected error:', error);
      return [];
    }
  }

  /**
   * Returns safe empty result for error cases.
   * @private
   */
  private getEmptyResult(): ConversationMemoryResult {
    return {
      recent: [],
      summary: null,
      turnCount: 0,
      hasLongHistory: false,
    };
  }
}
